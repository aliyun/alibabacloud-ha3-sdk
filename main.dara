import Util;
import String;
import EncodeUtil;

type @endpoint = string
type @instanceId = string
type @protocol = string
type @userAgent = string
type @credential = string
type @domainsuffix = string
type @runtimeOptions = Util.RuntimeOptions

model Config {
  endpoint?: string,
  instanceId?: string,
  protocol?: string,
  accessUserName?: string,
  accessPassWord?: string,
  userAgent?: string,
  runtimeOptions?: Util.RuntimeOptions
}

init(config: Config) {
  if (Util.isUnset(config)) {
    throw {
      name = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }
  if (!Util.empty(config.accessUserName) && !Util.empty(config.accessPassWord)) {
      @credential = getRealmSignStr(config.accessUserName, config.accessPassWord);
  }
  @endpoint = getEndpoint(config.endpoint);
  @instanceId = config.instanceId;
  @protocol = config.protocol;
  @userAgent = config.userAgent;
  @domainsuffix = 'ha.aliyuncs.com';
  @runtimeOptions = buildRuntimeOptions(config.runtimeOptions);
}

/**
 * 如果endpoint 配置以 http:// 或 https:// 开头，则去掉头部的 http:// 或 https://, 否则直接返回
 */
function getEndpoint(endpoint: string): string {
  if (String.hasPrefix(endpoint, 'http://')) {
    return String.replace(endpoint, 'http://', '', 1);
  }

  if (String.hasPrefix(endpoint, 'https://')) {
   return String.replace(endpoint, 'https://', '', 1);
  }

  return endpoint;
}

/**
 * 设置Client UA 配置.
 */
function setUserAgent(userAgent: string): void {
  @userAgent = userAgent;
}

/**
 * 添加Client UA 配置.
 */
function appendUserAgent(userAgent: string): void {
  @userAgent = `${@userAgent} ${userAgent}`;
}

/**
 * 获取Client 配置 UA 配置.
 */
function getUserAgent(): string {
  var userAgent = Util.getUserAgent(@userAgent);
  return userAgent;
}

/**
 * 计算用户请求识别特征, 遵循 Basic Auth 生成规范.
 */
function getRealmSignStr(accessUserName: string, accessPassWord: string): string {
  var accessUserNameStr = String.trim(accessUserName);
  var accessPassWordStr = String.trim(accessPassWord);
  var realmStr: string = `${accessUserNameStr}:${accessPassWordStr}`;
  return EncodeUtil.base64EncodeToString(String.toBytes(realmStr, 'UTF-8'));
}

model SearchResponse {
  headers?: map[string]string(description='headers', name='headers'),
  body: string(description='body', name='body')
}

model QueryRequest {
  tableName: string(name='tableName', description='数据源名'),
  vector: [ float ](name='vector', description='向量数据'),
  namespace?: string(name='namespace', description='查询向量的空间'),
  topK?: integer(name='topK', description='返回个数'),
  indexName?: string(name='indexName', description='查询的索引名'),
  sparseData?: SparseData(name='sparseData', description='查询的稀疏向量'),
  weight?: float(name='weight', description='Query的权重'),
  content?: string(name='content', description='需要向量化的内容'),
  modal?: string(name='modal', description='使用的模型'),
  includeVector?: boolean(name='includeVector', description='是否返回文档中的向量信息'),
  outputFields?: [ string ](name='outputFields', description='需要返回值的字段列表'),
  order?: string(name='order', description='排序顺序, ASC：升序  DESC: 降序'),
  searchParams?: string(name='searchParams', description='查询参数'),
  filter?: string(name='filter', description='过滤表达式'),
  scoreThreshold?: float(name='scoreThreshold', description='分数过滤， 使用欧式距离时，只返回小于scoreThreshold的结果。使用内积时，只返回大于scoreThreshold的结果'),
  vectorCount?: integer(name='vectorCount', description='vector字段中包含的向量个数'),
  sort?: string(name='sort', description='排序表达式'),
  kvpairs?: map[string]string(name='kvpairs', description='kvpairs')
}

model SparseData {
  count?: [ integer ](name='count', description='每个稀疏向量中包含的元素个数'),
  indices: [ long ](name='indices', description='元素下标（需要从小到大排序）'),
  values: [ float ](name='values', description='元素值（与下标一一对应）')
}

model MultiQueryRequest {
  tableName: string(name='tableName', description='数据源名'),
  queries: [ QueryRequest ](name='queries', description='多向量列表'),
  topK?: integer(name='topK', description='返回个数'),
  includeVector?: boolean(name='includeVector', description='是否返回文档中的向量信息'),
  outputFields?: [ string ](name='outputFields', description='需要返回值的字段列表'),
  order?: string(name='order', description='排序顺序, ASC：升序  DESC: 降序'),
  filter?: string(name='filter', description='过滤表达式'),
  sort?: string(name='sort', description='排序表达式')
}

model FetchRequest {
  tableName: string(name='tableName', description='数据源名'),
  ids?: [ string ](name='ids', description='主键列表，如果传了主键列表，下面的条件参数不生效'),
  filter?: string(name='filter', description='过滤表达式'),
  sort?: string(name='sort', description='排序表达式'),
  limit?: integer(name='limit', description='返回的数据个数'),
  offset?: integer(name='offset', description='返回的数据开始下标，用于翻页'),
  includeVector?: boolean(name='includeVector', description='是否返回向量数据'),
  outputFields?: [ string ](name='outputFields', description='需要返回的字段，不指定默认返回所有的字段'),
  kvpairs?: map[string]string(name='kvpairs', description='kvpairs')
}

/**
 * 向量查询
 */
async function query(request: QueryRequest): SearchResponse {
  return _request('POST', `/vector-service/query`, null, null, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 向量预测查询
 */
async function inferenceQuery(request: QueryRequest): SearchResponse {
  return _request('POST', `/vector-service/inference-query`, null, null, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 多namespace查询
 */
async function multiQuery(request: MultiQueryRequest): SearchResponse {
  return _request('POST', `/vector-service/multi-query`, null, null, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 查询数据
 */
async function fetch(request: FetchRequest): SearchResponse {
  return _request('POST', `/vector-service/fetch`, null, null, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 文档统计
 */
async function stats(tableName: string): SearchResponse {
  var body: map[string]any = {
        tableName = tableName};
  return _request('POST', `/vector-service/stats`, null, null, Util.toJSONString(body), @runtimeOptions);
}

model PushDocumentsRequest {
  headers?: map[string]string(description='headers', name='headers'),
  body: [ map[string]any ](description='body', name='body')
}

model PushDocumentsResponse {
  headers?: map[string]string(description='headers', name='headers'),
  body: string(description='body', name='body')
}

/**
 * 支持新增、更新、删除 等操作，以及对应批量操作
 */
async function pushDocuments(dataSourceName: string, keyField: string, request: PushDocumentsRequest): PushDocumentsResponse {
  request.headers = {
    X-Opensearch-Swift-PK-Field = keyField,
    ...request.headers
  };
  return _request('POST', `/update/${dataSourceName}/actions/bulk`, null, request.headers, request.body, @runtimeOptions);
}

/**
 * 用于内网环境的新增、更新、删除 等操作，以及对应批量操作
 */
async function pushDocumentsWithSwift(dataSourceName: string, keyField: string, topic: string, swift: string, request: PushDocumentsRequest): PushDocumentsResponse {
  request.headers = {
    X-Opensearch-Swift-PK-Field = keyField,
    X-Opensearch-Swift-Topic = topic,
    X-Opensearch-Swift-Swift = swift
  };
  return _request('POST', `/update/${dataSourceName}/actions/bulk`, null, request.headers, request.body, @runtimeOptions);
}

api _request(method: string, pathname: string, query: map[string]any, headers: map[string]string, body: any, runtime: Util.RuntimeOptions): map[string]any {
  __request.protocol = Util.defaultString(@protocol, 'HTTP');
  __request.method = method;
  __request.pathname = pathname;
  __request.headers = {
    user-agent = getUserAgent(),
    host = Util.defaultString(@endpoint, `${@instanceId}.${@domainsuffix}`),
    authorization = `Basic ${@credential}`,
    content-type = 'application/json; charset=utf-8',
    ...headers
  };

  if (!Util.isUnset(query)) {
    __request.query = Util.stringifyMapValue(query);
    __request.headers.X-Opensearch-Request-ID = Util.getNonce();
  }

  if (!Util.isUnset(body)) {
    __request.headers.X-Opensearch-Swift-Request-ID = Util.getNonce();
    __request.body = Util.toJSONString(body);
  }
} returns {
  var objStr = Util.readAsString(__response.body);

  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var rawMsg:any = null;
      try {
        rawMsg = Util.parseJSON(objStr);
      } catch(err){
        rawMsg = objStr;
      }
    var rawMap: map[string]any = {
      errors = rawMsg
    };
    throw {
      message = __response.statusMessage,
      data = rawMap,
      code = __response.statusCode
    };
  }

  if (Util.empty(objStr)) {
    var rawbodyMap: map[string]any = {
      status = __response.statusMessage,
      code = __response.statusCode
    };
    return {
      body = Util.toJSONString(rawbodyMap),
      headers = __response.headers
    };
  }
  return {
    body = objStr,
    headers = __response.headers
  };
} runtime {
  timeouted = 'retry',
  readTimeout = runtime.readTimeout,
  connectTimeout = runtime.connectTimeout,
  httpsProxy = runtime.httpsProxy,
  noProxy = runtime.noProxy,
  maxIdleConns = runtime.maxIdleConns,
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = runtime.maxAttempts
  },
  backoff = {
    policy = runtime.backoffPolicy,
    period = runtime.backoffPeriod
  },
  ignoreSSL = runtime.ignoreSSL
}

/**
 * 构建RuntimeOptions
 */
function buildRuntimeOptions(runtimeOptions: Util.RuntimeOptions): Util.RuntimeOptions {
  if (Util.isUnset(runtimeOptions)) {
    return new Util.RuntimeOptions{
      readTimeout = 10000,
      connectTimeout = 5000,
      autoretry = false,
      ignoreSSL = false,
      maxIdleConns = 50,
    };
  }

  if (Util.isUnset(runtimeOptions.readTimeout)) {
    runtimeOptions.readTimeout = 10000;
  }
  if (Util.isUnset(runtimeOptions.connectTimeout)) {
    runtimeOptions.connectTimeout = 5000;
  }
  if (Util.isUnset(runtimeOptions.maxIdleConns)) {
    runtimeOptions.maxIdleConns = 50;
  }
  if (Util.isUnset(runtimeOptions.maxAttempts)) {
    runtimeOptions.maxAttempts = 5;
  }
  if (Util.isUnset(runtimeOptions.backoffPolicy)) {
    runtimeOptions.backoffPolicy = 'no';
  }
  if (Util.isUnset(runtimeOptions.backoffPeriod)) {
    runtimeOptions.backoffPeriod = 1;
  }
  return runtimeOptions;
}
