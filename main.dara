import Util;
import String;
import EncodeUtil;
import Ha3Util;

type @endpoint = string
type @instanceId = string
type @protocol = string
type @userAgent = string
type @credential = string
type @domainsuffix = string
type @runtimeOptions = Util.RuntimeOptions

model Config {
  endpoint?: string,
  instanceId?: string,
  protocol?: string,
  accessUserName?: string,
  accessPassWord?: string,
  userAgent?: string,
  runtimeOptions?: Util.RuntimeOptions
}

init(config: Config) {
  if (Util.isUnset(config)) {
    throw {
      name = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }
  if (!Util.empty(config.accessUserName) && !Util.empty(config.accessPassWord)) {
      @credential = getRealmSignStr(config.accessUserName, config.accessPassWord);
  }
  @endpoint = getEndpoint(config.endpoint);
  @instanceId = config.instanceId;
  @protocol = config.protocol;
  @userAgent = config.userAgent;
  @domainsuffix = 'ha.aliyuncs.com';
  @runtimeOptions = buildRuntimeOptions(config.runtimeOptions);
}

/**
 * 如果endpoint 配置以 http:// 或 https:// 开头，则去掉头部的 http:// 或 https://, 否则直接返回
 */
function getEndpoint(endpoint: string): string {
  if (String.hasPrefix(endpoint, 'http://')) {
    return String.replace(endpoint, 'http://', '', 1);
  }

  if (String.hasPrefix(endpoint, 'https://')) {
   return String.replace(endpoint, 'https://', '', 1);
  }

  return endpoint;
}

/**
 * 设置Client UA 配置.
 */
function setUserAgent(userAgent: string): void {
  @userAgent = userAgent;
}

/**
 * 添加Client UA 配置.
 */
function appendUserAgent(userAgent: string): void {
  @userAgent = `${@userAgent} ${userAgent}`;
}

/**
 * 获取Client 配置 UA 配置.
 */
function getUserAgent(): string {
  var userAgent = Util.getUserAgent(@userAgent);
  return userAgent;
}

/**
 * 计算用户请求识别特征, 遵循 Basic Auth 生成规范.
 */
function getRealmSignStr(accessUserName: string, accessPassWord: string): string {
  var accessUserNameStr = String.trim(accessUserName);
  var accessPassWordStr = String.trim(accessPassWord);
  var realmStr: string = `${accessUserNameStr}:${accessPassWordStr}`;
  return EncodeUtil.base64EncodeToString(String.toBytes(realmStr, 'UTF-8'));
}

model SearchResponse {
  headers?: map[string]string(description='headers', name='headers'),
  body: string(description='body', name='body')
}

model QueryRequest {
  tableName: string(name='tableName', description='数据源名'),
  vector: [ float ](name='vector', description='向量数据'),
  namespace?: string(name='namespace', description='查询向量的空间'),
  topK?: integer(name='topK', description='返回个数'),
  indexName?: string(name='indexName', description='查询的索引名'),
  sparseData?: SparseData(name='sparseData', description='查询的稀疏向量'),
  weight?: float(name='weight', description='Query的权重'),
  content?: string(name='content', description='需要向量化的内容'),
  modal?: string(name='modal', description='使用的模型'),
  includeVector?: boolean(name='includeVector', description='是否返回文档中的向量信息'),
  outputFields?: [ string ](name='outputFields', description='需要返回值的字段列表'),
  order?: string(name='order', description='排序顺序, ASC：升序  DESC: 降序'),
  searchParams?: string(name='searchParams', description='查询参数'),
  filter?: string(name='filter', description='过滤表达式'),
  scoreThreshold?: float(name='scoreThreshold', description='分数过滤， 使用欧式距离时，只返回小于scoreThreshold的结果。使用内积时，只返回大于scoreThreshold的结果'),
  vectorCount?: integer(name='vectorCount', description='vector字段中包含的向量个数'),
  sort?: string(name='sort', description='排序表达式'),
  kvpairs?: map[string]string(name='kvpairs', description='kvpairs')
}

model SparseData {
  count?: [ integer ](name='count', description='每个稀疏向量中包含的元素个数'),
  indices: [ long ](name='indices', description='元素下标（需要从小到大排序）'),
  values: [ float ](name='values', description='元素值（与下标一一对应）')
}

model MultiQueryRequest {
  tableName: string(name='tableName', description='数据源名'),
  queries: [ QueryRequest ](name='queries', description='多向量列表'),
  topK?: integer(name='topK', description='返回个数'),
  includeVector?: boolean(name='includeVector', description='是否返回文档中的向量信息'),
  outputFields?: [ string ](name='outputFields', description='需要返回值的字段列表'),
  order?: string(name='order', description='排序顺序, ASC：升序  DESC: 降序'),
  filter?: string(name='filter', description='过滤表达式'),
  sort?: string(name='sort', description='排序表达式')
}

model FetchRequest {
  tableName: string(name='tableName', description='数据源名'),
  ids?: [ string ](name='ids', description='主键列表，如果传了主键列表，下面的条件参数不生效'),
  filter?: string(name='filter', description='过滤表达式'),
  sort?: string(name='sort', description='排序表达式'),
  limit?: integer(name='limit', description='返回的数据个数'),
  offset?: integer(name='offset', description='返回的数据开始下标，用于翻页'),
  includeVector?: boolean(name='includeVector', description='是否返回向量数据'),
  outputFields?: [ string ](name='outputFields', description='需要返回的字段，不指定默认返回所有的字段'),
  kvpairs?: map[string]string(name='kvpairs', description='kvpairs')
}

model RankQuery {
  rrf?: map[string]string(name='rrf', description='查询表达式'),
}

model TextQuery {
  queryString: string(name='queryString', description='ha3 query语法，支持多个文本索引的AND、OR嵌套'),
  queryParams?: map[string]string(name='queryParams', description='query查询参数：
      default_op: 指定在该次查询中使用的默认query 分词后的连接操作符，AND or OR。默认为AND。
      global_analyzer: 查询中指定全局的分词器，该分词器会覆盖schema的分词器，指定的值必须在analyzer.json里有配置。
      specific_index_analyzer: 查询中指定index使用另外的分词器，该分词器会覆盖global_analyzer和schema的分词器。
      no_token_indexes: 支持查询中指定的index不分词（除分词以外的其他流程如归一化、去停用词会正常执行），多个index之间用;分割。
      remove_stopwords: true or false 表示是否需要删除stop words，stop words在分词器中配置。默认true'),
  filter?: string(name='filter', description='过滤条件表达式'),
  weight?: float(name='weight', description='text查询结果的权重，以score * weight的结果作为该路的排序分'),
  terminateAfter?: integer(name='terminateAfter', description='每个分片查找满足条件的文档的最大数量。到达这个数量后，查询将提前结束，不再继续查询索引。默认为0，不设置限制。')
}

model SearchRequest{
 tableName: string(name='tableName', description='数据源名'),
 size?: integer(name='size', description='返回结果的个数'),
 from?: integer(name='from', description='从结果集的第from返回doc'),
 order?: string(name='order', description='结果排序方向:DESC: 降序排序;ASC: 升序排序'),
 outputFields?: [ string ](name='outputFields', description='指定需要在结果中返回的字段，默认为空'),
 knn?: QueryRequest(name='knn', description='KNN查询参数'),
 text?: TextQuery(name='text', description='text查询参数'),
 rank?: RankQuery(name='rank', description='指定两路结果融合的方式，目前支持两种策略：默认策略：两路结果中相同pk的doc的分数按权重相加。按加权后的分数排序。rrf: 使用rrf融合两路结果')
}

model AggFuncDesc {
  name?: string(name='name', description='可以指定统计值在结果集中字段的名称。默认结果字段为: FUNC_NAME(args)'),
  func: string(name='func', description='统计函数名：max, min, avg, sum, count', required=true),
  args: [ string ](name='args', description='统计函数的参数', required=true)
}

model OrderByDesc {
  field: string(name='field', description='排序字段名称，必须指定结果集中的字段', required=true),
  direction?: string(name='direction', description='排序方向，DESC: 降序排列；ASC: 升序排列')
}

model AggregateRequest {
  tableName: string(name='tableName', description='需要统计的表名', required=true),
  filter?: string(name='filter', description='过滤条件'),
  groupKeys?: [ string ](name='groupKeys', description='分组统计的字段列表'),
  aggFuncs: [ AggFuncDesc ](name='aggFuncs', description='统计函数列表', required=true),
  orderBy?: [ OrderByDesc ](name='orderBy', description='统计结果排序方式，支持多维排序'),
  timeout?: integer(name='timeout', description='超时时间，单位毫秒')
}


/**
 * 向量查询
 */
async function query(request: QueryRequest): SearchResponse {
  var headers = getHeadersFromRunTimeOption();
  return _request('POST', `/vector-service/query`, null, headers, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 向量预测查询
 */
async function inferenceQuery(request: QueryRequest): SearchResponse {
  var headers = getHeadersFromRunTimeOption();

  return _request('POST', `/vector-service/inference-query`, null, headers, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 多namespace查询
 */
async function multiQuery(request: MultiQueryRequest): SearchResponse {
  var headers = getHeadersFromRunTimeOption();

  return _request('POST', `/vector-service/multi-query`, null, headers, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 查询数据
 */
async function fetch(request: FetchRequest): SearchResponse {
  var headers = getHeadersFromRunTimeOption();

  return _request('POST', `/vector-service/fetch`, null, headers, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 文本向量混合检索
 */
async function search(request: SearchRequest): SearchResponse {
  var headers = getHeadersFromRunTimeOption();

  return _request('POST', `/vector-service/search`, null, headers, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 向量引擎统计语法
 */
async function aggregate(request: AggregateRequest): SearchResponse {
  var headers = getHeadersFromRunTimeOption();

  return _request('POST', `/vector-service/aggregate`, null, headers, Util.toJSONString(request), @runtimeOptions);
}

/**
 * 文档统计
 */
async function stats(tableName: string): SearchResponse {
  var body: map[string]any = {
        tableName = tableName};
  return _request('POST', `/vector-service/stats`, null, null, Util.toJSONString(body), @runtimeOptions);
}


/**
 * 校验网络是否通畅
 * 检查vpc & 用户名密码配置是否正确
 */
async function active(): SearchResponse {
  return _request('GET', `/network/active`, null, null, null, @runtimeOptions);
}


model PushDocumentsRequest {
  headers?: map[string]string(description='headers', name='headers'),
  body: [ map[string]any ](description='body', name='body')
}

model PushDocumentsResponse {
  headers?: map[string]string(description='headers', name='headers'),
  body: string(description='body', name='body')
}

/**
 * 支持新增、更新、删除 等操作，以及对应批量操作
 */
async function pushDocuments(dataSourceName: string, keyField: string, request: PushDocumentsRequest): PushDocumentsResponse {
  request.headers = {
    X-Opensearch-Swift-PK-Field = keyField,
    ...request.headers
  };
  return _request('POST', `/update/${dataSourceName}/actions/bulk`, null, request.headers, request.body, @runtimeOptions);
}

api _request(method: string, pathname: string, query: map[string]any, headers: map[string]string, body: any, runtime: Util.RuntimeOptions): map[string]any {
  __request.protocol = Util.defaultString(@protocol, 'HTTP');
  __request.method = method;
  __request.pathname = pathname;
  __request.headers = {
    user-agent = getUserAgent(),
    host = Util.defaultString(@endpoint, `${@instanceId}.${@domainsuffix}`),
    authorization = `Basic ${@credential}`,
    content-type = 'application/json; charset=utf-8',
    ...headers
  };

  if (!Util.isUnset(query)) {
    __request.query = Util.stringifyMapValue(query);
    __request.headers.X-Opensearch-Request-ID = Util.getNonce();
  }

  if (!Util.isUnset(body)) {
    __request.headers.X-Opensearch-Swift-Request-ID = Util.getNonce();
    if (String.equals("deflate", __request.headers.Content-Encoding) && !String.contains(pathname, "actions/bulk")) {
        var compressed = Ha3Util.deflateCompress(String.toBytes(Util.toJSONString(body), 'UTF-8'));
        __request.body = compressed;
    } else {
        __request.body = Util.toJSONString(body);
    }
  }
} returns {
  var objStr = Util.readAsString(__response.body);

  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var rawMsg:any = null;
      try {
        rawMsg = Util.parseJSON(objStr);
      } catch(err){
        rawMsg = objStr;
      }
    var rawMap: map[string]any = {
      errors = rawMsg
    };
    throw {
      message = __response.statusMessage,
      data = rawMap,
      code = __response.statusCode
    };
  }

  if (Util.empty(objStr)) {
    var rawbodyMap: map[string]any = {
      status = __response.statusMessage,
      code = __response.statusCode
    };
    return {
      body = Util.toJSONString(rawbodyMap),
      headers = __response.headers
    };
  }
  return {
    body = objStr,
    headers = __response.headers
  };
} runtime {
  timeouted = 'retry',
  readTimeout = runtime.readTimeout,
  connectTimeout = runtime.connectTimeout,
  httpsProxy = runtime.httpsProxy,
  noProxy = runtime.noProxy,
  maxIdleConns = runtime.maxIdleConns,
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = runtime.maxAttempts
  },
  backoff = {
    policy = runtime.backoffPolicy,
    period = runtime.backoffPeriod
  },
  ignoreSSL = runtime.ignoreSSL
}

/**
 * 构建RuntimeOptions
 */
function buildRuntimeOptions(runtimeOptions: Util.RuntimeOptions): Util.RuntimeOptions {
  if (Util.isUnset(runtimeOptions)) {
    return new Util.RuntimeOptions{
      readTimeout = 10000,
      connectTimeout = 5000,
      autoretry = false,
      ignoreSSL = false,
      maxIdleConns = 50
    };
  }

  if (Util.isUnset(runtimeOptions.readTimeout)) {
    runtimeOptions.readTimeout = 10000;
  }
  if (Util.isUnset(runtimeOptions.connectTimeout)) {
    runtimeOptions.connectTimeout = 5000;
  }
  if (Util.isUnset(runtimeOptions.maxIdleConns)) {
    runtimeOptions.maxIdleConns = 50;
  }
  if (Util.isUnset(runtimeOptions.maxAttempts)) {
    runtimeOptions.maxAttempts = 5;
  }
  if (Util.isUnset(runtimeOptions.backoffPolicy)) {
    runtimeOptions.backoffPolicy = 'no';
  }
  if (Util.isUnset(runtimeOptions.backoffPeriod)) {
    runtimeOptions.backoffPeriod = 1;
  }
  return runtimeOptions;
}


/**
 * 从runtimeoptions中获取headers
 */
function getHeadersFromRunTimeOption(): map[string]string {
  var options = @runtimeOptions;
  var headers: map[string]string = {};

  if (!Util.isUnset(options.extendsParameters) && !Util.isUnset(options.extendsParameters.headers) && !Util.empty(options.extendsParameters.headers.Content-Encoding)) {
    var contentEncoding = options.extendsParameters.headers.Content-Encoding;
    if (String.equals("deflate", contentEncoding)) {
      headers.Content-Encoding = "deflate";
    }
  }
  return headers;
}

